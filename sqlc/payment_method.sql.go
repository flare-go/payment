// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payment_method.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentMethod = `-- name: CreatePaymentMethod :exec
INSERT INTO payment_methods (
    id,
    customer_id,
    type,
    card_last4,
    card_brand,
    card_exp_month,
    card_exp_year,
    bank_account_last4,
    bank_account_bank_name,
    is_default
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         )
`

type CreatePaymentMethodParams struct {
	ID                  string            `json:"id"`
	CustomerID          string            `json:"customerId"`
	Type                PaymentMethodType `json:"type"`
	CardLast4           *string           `json:"cardLast4"`
	CardBrand           *string           `json:"cardBrand"`
	CardExpMonth        *int32            `json:"cardExpMonth"`
	CardExpYear         *int32            `json:"cardExpYear"`
	BankAccountLast4    *string           `json:"bankAccountLast4"`
	BankAccountBankName *string           `json:"bankAccountBankName"`
	IsDefault           bool              `json:"isDefault"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) error {
	_, err := q.db.Exec(ctx, createPaymentMethod,
		arg.ID,
		arg.CustomerID,
		arg.Type,
		arg.CardLast4,
		arg.CardBrand,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.BankAccountLast4,
		arg.BankAccountBankName,
		arg.IsDefault,
	)
	return err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec

DELETE FROM payment_methods WHERE id = $1
`

// RETURNING id, customer_id, type, card_last4, card_brand, card_exp_month, card_exp_year, bank_account_last4, bank_account_bank_name, is_default, stripe_id, created_at, updated_at;
func (q *Queries) DeletePaymentMethod(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePaymentMethod, id)
	return err
}

const getPaymentMethod = `-- name: GetPaymentMethod :one

SELECT id, customer_id, type, card_last4, card_brand, card_exp_month, card_exp_year, bank_account_last4, bank_account_bank_name, is_default, created_at, updated_at
FROM payment_methods
WHERE id = $1
`

// RETURNING id, customer_id, type, card_last4, card_brand, card_exp_month, card_exp_year, bank_account_last4, bank_account_bank_name, is_default, stripe_id, created_at, updated_at;
func (q *Queries) GetPaymentMethod(ctx context.Context, id string) (*PaymentMethod, error) {
	row := q.db.QueryRow(ctx, getPaymentMethod, id)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.CardLast4,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.BankAccountLast4,
		&i.BankAccountBankName,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listPaymentMethods = `-- name: ListPaymentMethods :many
SELECT id, customer_id, type, card_last4, card_brand, card_exp_month, card_exp_year, bank_account_last4, bank_account_bank_name, is_default, created_at, updated_at
FROM payment_methods
WHERE customer_id = $1
ORDER BY is_default DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentMethodsParams struct {
	CustomerID string `json:"customerId"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

func (q *Queries) ListPaymentMethods(ctx context.Context, arg ListPaymentMethodsParams) ([]*PaymentMethod, error) {
	rows, err := q.db.Query(ctx, listPaymentMethods, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PaymentMethod{}
	for rows.Next() {
		var i PaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.CardLast4,
			&i.CardBrand,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.BankAccountLast4,
			&i.BankAccountBankName,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentMethod = `-- name: UpdatePaymentMethod :exec
UPDATE payment_methods
SET
    type = $2,
    card_last4 = $3,
    card_brand = $4,
    card_exp_month = $5,
    card_exp_year = $6,
    bank_account_last4 = $7,
    bank_account_bank_name = $8,
    is_default = $9,
    updated_at = NOW()
WHERE
    id = $1
  AND updated_at = $10
`

type UpdatePaymentMethodParams struct {
	ID                  string             `json:"id"`
	Type                PaymentMethodType  `json:"type"`
	CardLast4           *string            `json:"cardLast4"`
	CardBrand           *string            `json:"cardBrand"`
	CardExpMonth        *int32             `json:"cardExpMonth"`
	CardExpYear         *int32             `json:"cardExpYear"`
	BankAccountLast4    *string            `json:"bankAccountLast4"`
	BankAccountBankName *string            `json:"bankAccountBankName"`
	IsDefault           bool               `json:"isDefault"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) UpdatePaymentMethod(ctx context.Context, arg UpdatePaymentMethodParams) error {
	_, err := q.db.Exec(ctx, updatePaymentMethod,
		arg.ID,
		arg.Type,
		arg.CardLast4,
		arg.CardBrand,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.BankAccountLast4,
		arg.BankAccountBankName,
		arg.IsDefault,
		arg.UpdatedAt,
	)
	return err
}

const upsertPaymentMethod = `-- name: UpsertPaymentMethod :exec
INSERT INTO payment_methods (
    id,
    customer_id,
    type,
    card_last4,
    card_brand,
    card_exp_month,
    card_exp_year,
    bank_account_last4,
    bank_account_bank_name,
    is_default
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         )
ON CONFLICT (id)
    DO UPDATE SET
                  customer_id = EXCLUDED.customer_id,
                  type = EXCLUDED.type,
                  card_last4 = EXCLUDED.card_last4,
                  card_brand = EXCLUDED.card_brand,
                  card_exp_month = EXCLUDED.card_exp_month,
                  card_exp_year = EXCLUDED.card_exp_year,
                  bank_account_last4 = EXCLUDED.bank_account_last4,
                  bank_account_bank_name = EXCLUDED.bank_account_bank_name,
                  is_default = EXCLUDED.is_default,
                  updated_at = NOW()
`

type UpsertPaymentMethodParams struct {
	ID                  string            `json:"id"`
	CustomerID          string            `json:"customerId"`
	Type                PaymentMethodType `json:"type"`
	CardLast4           *string           `json:"cardLast4"`
	CardBrand           *string           `json:"cardBrand"`
	CardExpMonth        *int32            `json:"cardExpMonth"`
	CardExpYear         *int32            `json:"cardExpYear"`
	BankAccountLast4    *string           `json:"bankAccountLast4"`
	BankAccountBankName *string           `json:"bankAccountBankName"`
	IsDefault           bool              `json:"isDefault"`
}

func (q *Queries) UpsertPaymentMethod(ctx context.Context, arg UpsertPaymentMethodParams) error {
	_, err := q.db.Exec(ctx, upsertPaymentMethod,
		arg.ID,
		arg.CustomerID,
		arg.Type,
		arg.CardLast4,
		arg.CardBrand,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.BankAccountLast4,
		arg.BankAccountBankName,
		arg.IsDefault,
	)
	return err
}
