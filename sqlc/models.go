// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type Currency string

const (
	CurrencyUSD Currency = "USD"
	CurrencyEUR Currency = "EUR"
	CurrencyJPY Currency = "JPY"
	CurrencyTWD Currency = "TWD"
)

func (e *Currency) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Currency(s)
	case string:
		*e = Currency(s)
	default:
		return fmt.Errorf("unsupported scan type for Currency: %T", src)
	}
	return nil
}

type NullCurrency struct {
	Currency Currency `json:"currency"`
	Valid    bool     `json:"valid"` // Valid is true if Currency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCurrency) Scan(value interface{}) error {
	if value == nil {
		ns.Currency, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Currency.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCurrency) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Currency), nil
}

func (e Currency) Valid() bool {
	switch e {
	case CurrencyUSD,
		CurrencyEUR,
		CurrencyJPY,
		CurrencyTWD:
		return true
	}
	return false
}

type IntervalType string

const (
	IntervalTypeDay   IntervalType = "day"
	IntervalTypeWeek  IntervalType = "week"
	IntervalTypeMonth IntervalType = "month"
	IntervalTypeYear  IntervalType = "year"
)

func (e *IntervalType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IntervalType(s)
	case string:
		*e = IntervalType(s)
	default:
		return fmt.Errorf("unsupported scan type for IntervalType: %T", src)
	}
	return nil
}

type NullIntervalType struct {
	IntervalType IntervalType `json:"intervalType"`
	Valid        bool         `json:"valid"` // Valid is true if IntervalType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIntervalType) Scan(value interface{}) error {
	if value == nil {
		ns.IntervalType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IntervalType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIntervalType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IntervalType), nil
}

func (e IntervalType) Valid() bool {
	switch e {
	case IntervalTypeDay,
		IntervalTypeWeek,
		IntervalTypeMonth,
		IntervalTypeYear:
		return true
	}
	return false
}

type InvoiceStatus string

const (
	InvoiceStatusDRAFT         InvoiceStatus = "DRAFT"
	InvoiceStatusOPEN          InvoiceStatus = "OPEN"
	InvoiceStatusPAID          InvoiceStatus = "PAID"
	InvoiceStatusPARTIALLYPAID InvoiceStatus = "PARTIALLY_PAID"
	InvoiceStatusUNCOLLECTIBLE InvoiceStatus = "UNCOLLECTIBLE"
	InvoiceStatusVOID          InvoiceStatus = "VOID"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoiceStatus"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

func (e InvoiceStatus) Valid() bool {
	switch e {
	case InvoiceStatusDRAFT,
		InvoiceStatusOPEN,
		InvoiceStatusPAID,
		InvoiceStatusPARTIALLYPAID,
		InvoiceStatusUNCOLLECTIBLE,
		InvoiceStatusVOID:
		return true
	}
	return false
}

type PaymentIntentStatus string

const (
	PaymentIntentStatusREQUIRESPAYMENTMETHOD PaymentIntentStatus = "REQUIRES_PAYMENT_METHOD"
	PaymentIntentStatusREQUIRESCONFIRMATION  PaymentIntentStatus = "REQUIRES_CONFIRMATION"
	PaymentIntentStatusREQUIRESACTION        PaymentIntentStatus = "REQUIRES_ACTION"
	PaymentIntentStatusPROCESSING            PaymentIntentStatus = "PROCESSING"
	PaymentIntentStatusSUCCEEDED             PaymentIntentStatus = "SUCCEEDED"
	PaymentIntentStatusCANCELED              PaymentIntentStatus = "CANCELED"
)

func (e *PaymentIntentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentIntentStatus(s)
	case string:
		*e = PaymentIntentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentIntentStatus: %T", src)
	}
	return nil
}

type NullPaymentIntentStatus struct {
	PaymentIntentStatus PaymentIntentStatus `json:"paymentIntentStatus"`
	Valid               bool                `json:"valid"` // Valid is true if PaymentIntentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentIntentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentIntentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentIntentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentIntentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentIntentStatus), nil
}

func (e PaymentIntentStatus) Valid() bool {
	switch e {
	case PaymentIntentStatusREQUIRESPAYMENTMETHOD,
		PaymentIntentStatusREQUIRESCONFIRMATION,
		PaymentIntentStatusREQUIRESACTION,
		PaymentIntentStatusPROCESSING,
		PaymentIntentStatusSUCCEEDED,
		PaymentIntentStatusCANCELED:
		return true
	}
	return false
}

type PaymentMethodType string

const (
	PaymentMethodTypeCARD        PaymentMethodType = "CARD"
	PaymentMethodTypeBANKACCOUNT PaymentMethodType = "BANK_ACCOUNT"
)

func (e *PaymentMethodType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentMethodType(s)
	case string:
		*e = PaymentMethodType(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentMethodType: %T", src)
	}
	return nil
}

type NullPaymentMethodType struct {
	PaymentMethodType PaymentMethodType `json:"paymentMethodType"`
	Valid             bool              `json:"valid"` // Valid is true if PaymentMethodType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentMethodType) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentMethodType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentMethodType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentMethodType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentMethodType), nil
}

func (e PaymentMethodType) Valid() bool {
	switch e {
	case PaymentMethodTypeCARD,
		PaymentMethodTypeBANKACCOUNT:
		return true
	}
	return false
}

type PriceType string

const (
	PriceTypeONETIME   PriceType = "ONE_TIME"
	PriceTypeRECURRING PriceType = "RECURRING"
)

func (e *PriceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PriceType(s)
	case string:
		*e = PriceType(s)
	default:
		return fmt.Errorf("unsupported scan type for PriceType: %T", src)
	}
	return nil
}

type NullPriceType struct {
	PriceType PriceType `json:"priceType"`
	Valid     bool      `json:"valid"` // Valid is true if PriceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPriceType) Scan(value interface{}) error {
	if value == nil {
		ns.PriceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PriceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPriceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PriceType), nil
}

func (e PriceType) Valid() bool {
	switch e {
	case PriceTypeONETIME,
		PriceTypeRECURRING:
		return true
	}
	return false
}

type RefundStatus string

const (
	RefundStatusPENDING   RefundStatus = "PENDING"
	RefundStatusSUCCEEDED RefundStatus = "SUCCEEDED"
	RefundStatusFAILED    RefundStatus = "FAILED"
	RefundStatusCANCELED  RefundStatus = "CANCELED"
)

func (e *RefundStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RefundStatus(s)
	case string:
		*e = RefundStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RefundStatus: %T", src)
	}
	return nil
}

type NullRefundStatus struct {
	RefundStatus RefundStatus `json:"refundStatus"`
	Valid        bool         `json:"valid"` // Valid is true if RefundStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRefundStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RefundStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RefundStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRefundStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RefundStatus), nil
}

func (e RefundStatus) Valid() bool {
	switch e {
	case RefundStatusPENDING,
		RefundStatusSUCCEEDED,
		RefundStatusFAILED,
		RefundStatusCANCELED:
		return true
	}
	return false
}

type SubscriptionStatus string

const (
	SubscriptionStatusACTIVE            SubscriptionStatus = "ACTIVE"
	SubscriptionStatusPASTDUE           SubscriptionStatus = "PAST_DUE"
	SubscriptionStatusUNPAID            SubscriptionStatus = "UNPAID"
	SubscriptionStatusCANCELED          SubscriptionStatus = "CANCELED"
	SubscriptionStatusINCOMPLETE        SubscriptionStatus = "INCOMPLETE"
	SubscriptionStatusINCOMPLETEEXPIRED SubscriptionStatus = "INCOMPLETE_EXPIRED"
	SubscriptionStatusTRIALING          SubscriptionStatus = "TRIALING"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscriptionStatus"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

func (e SubscriptionStatus) Valid() bool {
	switch e {
	case SubscriptionStatusACTIVE,
		SubscriptionStatusPASTDUE,
		SubscriptionStatusUNPAID,
		SubscriptionStatusCANCELED,
		SubscriptionStatusINCOMPLETE,
		SubscriptionStatusINCOMPLETEEXPIRED,
		SubscriptionStatusTRIALING:
		return true
	}
	return false
}

type Customer struct {
	ID        uint64             `json:"id"`
	UserID    uint64             `json:"userId"`
	Balance   int64              `json:"balance"`
	StripeID  string             `json:"stripeId"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

type Invoice struct {
	ID              uint64             `json:"id"`
	CustomerID      uint64             `json:"customerId"`
	SubscriptionID  uint64             `json:"subscriptionId"`
	Status          InvoiceStatus      `json:"status"`
	Currency        Currency           `json:"currency"`
	AmountDue       float64            `json:"amountDue"`
	AmountPaid      float64            `json:"amountPaid"`
	AmountRemaining float64            `json:"amountRemaining"`
	DueDate         pgtype.Timestamptz `json:"dueDate"`
	PaidAt          pgtype.Timestamptz `json:"paidAt"`
	StripeID        string             `json:"stripeId"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz `json:"updatedAt"`
}

type InvoiceItem struct {
	ID          uint64             `json:"id"`
	InvoiceID   uint64             `json:"invoiceId"`
	Amount      float64            `json:"amount"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
}

type PaymentIntent struct {
	ID               uint64              `json:"id"`
	CustomerID       uint64              `json:"customerId"`
	Amount           float64             `json:"amount"`
	Currency         Currency            `json:"currency"`
	Status           PaymentIntentStatus `json:"status"`
	PaymentMethodID  uint64              `json:"paymentMethodId"`
	SetupFutureUsage string              `json:"setupFutureUsage"`
	StripeID         string              `json:"stripeId"`
	ClientSecret     string              `json:"clientSecret"`
	CreatedAt        pgtype.Timestamptz  `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz  `json:"updatedAt"`
}

type PaymentMethod struct {
	ID                  uint64             `json:"id"`
	CustomerID          uint64             `json:"customerId"`
	Type                PaymentMethodType  `json:"type"`
	CardLast4           *string            `json:"cardLast4"`
	CardBrand           *string            `json:"cardBrand"`
	CardExpMonth        *int32             `json:"cardExpMonth"`
	CardExpYear         *int32             `json:"cardExpYear"`
	BankAccountLast4    *string            `json:"bankAccountLast4"`
	BankAccountBankName *string            `json:"bankAccountBankName"`
	IsDefault           bool               `json:"isDefault"`
	StripeID            string             `json:"stripeId"`
	CreatedAt           pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
}

type Price struct {
	ID                     uint64             `json:"id"`
	ProductID              uint64             `json:"productId"`
	Type                   PriceType          `json:"type"`
	Currency               Currency           `json:"currency"`
	UnitAmount             float64            `json:"unitAmount"`
	RecurringInterval      NullIntervalType   `json:"recurringInterval"`
	RecurringIntervalCount int32              `json:"recurringIntervalCount"`
	TrialPeriodDays        int32              `json:"trialPeriodDays"`
	Active                 bool               `json:"active"`
	StripeID               string             `json:"stripeId"`
	CreatedAt              pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt              pgtype.Timestamptz `json:"updatedAt"`
}

type Product struct {
	ID          uint64             `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description"`
	Active      bool               `json:"active"`
	Metadata    []byte             `json:"metadata"`
	StripeID    string             `json:"stripeId"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
}

type Refund struct {
	ID              uint64             `json:"id"`
	PaymentIntentID uint64             `json:"paymentIntentId"`
	Amount          float64            `json:"amount"`
	Status          RefundStatus       `json:"status"`
	Reason          *string            `json:"reason"`
	StripeID        string             `json:"stripeId"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz `json:"updatedAt"`
}

type Subscription struct {
	ID                 uint64             `json:"id"`
	CustomerID         uint64             `json:"customerId"`
	PriceID            uint64             `json:"priceId"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"currentPeriodStart"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"currentPeriodEnd"`
	CanceledAt         pgtype.Timestamptz `json:"canceledAt"`
	CancelAtPeriodEnd  bool               `json:"cancelAtPeriodEnd"`
	TrialStart         pgtype.Timestamptz `json:"trialStart"`
	TrialEnd           pgtype.Timestamptz `json:"trialEnd"`
	StripeID           string             `json:"stripeId"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
}
