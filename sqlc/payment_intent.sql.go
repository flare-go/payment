// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payment_intent.sql

package sqlc

import (
	"context"
)

const createPaymentIntent = `-- name: CreatePaymentIntent :one
INSERT INTO payment_intents (
    customer_id,
    amount,
    currency,
    status,
    payment_method_id,
    setup_future_usage,
    stripe_id,
    client_secret
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
RETURNING id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at
`

type CreatePaymentIntentParams struct {
	CustomerID       int32               `json:"customerId"`
	Amount           int64               `json:"amount"`
	Currency         Currency            `json:"currency"`
	Status           PaymentIntentStatus `json:"status"`
	PaymentMethodID  *int32              `json:"paymentMethodId"`
	SetupFutureUsage *string             `json:"setupFutureUsage"`
	StripeID         string              `json:"stripeId"`
	ClientSecret     string              `json:"clientSecret"`
}

func (q *Queries) CreatePaymentIntent(ctx context.Context, arg CreatePaymentIntentParams) (*PaymentIntent, error) {
	row := q.db.QueryRow(ctx, createPaymentIntent,
		arg.CustomerID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethodID,
		arg.SetupFutureUsage,
		arg.StripeID,
		arg.ClientSecret,
	)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.SetupFutureUsage,
		&i.StripeID,
		&i.ClientSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPaymentIntent = `-- name: GetPaymentIntent :one
SELECT id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at
FROM payment_intents
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPaymentIntent(ctx context.Context, id uint32) (*PaymentIntent, error) {
	row := q.db.QueryRow(ctx, getPaymentIntent, id)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.SetupFutureUsage,
		&i.StripeID,
		&i.ClientSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listPaymentIntents = `-- name: ListPaymentIntents :many
SELECT id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at
FROM payment_intents
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentIntentsParams struct {
	CustomerID int32 `json:"customerId"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

func (q *Queries) ListPaymentIntents(ctx context.Context, arg ListPaymentIntentsParams) ([]*PaymentIntent, error) {
	rows, err := q.db.Query(ctx, listPaymentIntents, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PaymentIntent{}
	for rows.Next() {
		var i PaymentIntent
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethodID,
			&i.SetupFutureUsage,
			&i.StripeID,
			&i.ClientSecret,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentIntent = `-- name: UpdatePaymentIntent :one
UPDATE payment_intents
SET status = $2,
    payment_method_id = $3,
    setup_future_usage = $4,
    stripe_id = $5,
    client_secret = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at
`

type UpdatePaymentIntentParams struct {
	ID               uint32              `json:"id"`
	Status           PaymentIntentStatus `json:"status"`
	PaymentMethodID  *int32              `json:"paymentMethodId"`
	SetupFutureUsage *string             `json:"setupFutureUsage"`
	StripeID         string              `json:"stripeId"`
	ClientSecret     string              `json:"clientSecret"`
}

func (q *Queries) UpdatePaymentIntent(ctx context.Context, arg UpdatePaymentIntentParams) (*PaymentIntent, error) {
	row := q.db.QueryRow(ctx, updatePaymentIntent,
		arg.ID,
		arg.Status,
		arg.PaymentMethodID,
		arg.SetupFutureUsage,
		arg.StripeID,
		arg.ClientSecret,
	)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.SetupFutureUsage,
		&i.StripeID,
		&i.ClientSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
