// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payment_intent.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentIntent = `-- name: CreatePaymentIntent :exec
INSERT INTO payment_intents (
    id,
    customer_id,
    amount,
    currency,
    status,
    payment_method_id,
    capture_method,
    setup_future_usage,
    client_secret
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8,$9
         )
`

type CreatePaymentIntentParams struct {
	ID               string                            `json:"id"`
	CustomerID       string                            `json:"customerId"`
	Amount           float64                           `json:"amount"`
	Currency         Currency                          `json:"currency"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	CaptureMethod    PaymentIntentCaptureMethod        `json:"captureMethod"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
}

func (q *Queries) CreatePaymentIntent(ctx context.Context, arg CreatePaymentIntentParams) error {
	_, err := q.db.Exec(ctx, createPaymentIntent,
		arg.ID,
		arg.CustomerID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethodID,
		arg.CaptureMethod,
		arg.SetupFutureUsage,
		arg.ClientSecret,
	)
	return err
}

const getPaymentIntent = `-- name: GetPaymentIntent :one

SELECT id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, client_secret,capture_method, created_at, updated_at
FROM payment_intents
WHERE id = $1 LIMIT 1
`

type GetPaymentIntentRow struct {
	ID               string                            `json:"id"`
	CustomerID       string                            `json:"customerId"`
	Amount           float64                           `json:"amount"`
	Currency         Currency                          `json:"currency"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
	CaptureMethod    PaymentIntentCaptureMethod        `json:"captureMethod"`
	CreatedAt        pgtype.Timestamptz                `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz                `json:"updatedAt"`
}

// RETURNING id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at;
func (q *Queries) GetPaymentIntent(ctx context.Context, id string) (*GetPaymentIntentRow, error) {
	row := q.db.QueryRow(ctx, getPaymentIntent, id)
	var i GetPaymentIntentRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.SetupFutureUsage,
		&i.ClientSecret,
		&i.CaptureMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listPaymentIntents = `-- name: ListPaymentIntents :many

SELECT id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, client_secret, capture_method, created_at, updated_at
FROM payment_intents
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPaymentIntentsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPaymentIntentsRow struct {
	ID               string                            `json:"id"`
	CustomerID       string                            `json:"customerId"`
	Amount           float64                           `json:"amount"`
	Currency         Currency                          `json:"currency"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
	CaptureMethod    PaymentIntentCaptureMethod        `json:"captureMethod"`
	CreatedAt        pgtype.Timestamptz                `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz                `json:"updatedAt"`
}

// RETURNING id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, stripe_id, client_secret, created_at, updated_at;
func (q *Queries) ListPaymentIntents(ctx context.Context, arg ListPaymentIntentsParams) ([]*ListPaymentIntentsRow, error) {
	rows, err := q.db.Query(ctx, listPaymentIntents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPaymentIntentsRow{}
	for rows.Next() {
		var i ListPaymentIntentsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethodID,
			&i.SetupFutureUsage,
			&i.ClientSecret,
			&i.CaptureMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentIntentsByCustomer = `-- name: ListPaymentIntentsByCustomer :many
SELECT id, customer_id, amount, currency, status, payment_method_id, setup_future_usage, client_secret, capture_method, created_at, updated_at
FROM payment_intents
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentIntentsByCustomerParams struct {
	CustomerID string `json:"customerId"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

type ListPaymentIntentsByCustomerRow struct {
	ID               string                            `json:"id"`
	CustomerID       string                            `json:"customerId"`
	Amount           float64                           `json:"amount"`
	Currency         Currency                          `json:"currency"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
	CaptureMethod    PaymentIntentCaptureMethod        `json:"captureMethod"`
	CreatedAt        pgtype.Timestamptz                `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz                `json:"updatedAt"`
}

func (q *Queries) ListPaymentIntentsByCustomer(ctx context.Context, arg ListPaymentIntentsByCustomerParams) ([]*ListPaymentIntentsByCustomerRow, error) {
	rows, err := q.db.Query(ctx, listPaymentIntentsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPaymentIntentsByCustomerRow{}
	for rows.Next() {
		var i ListPaymentIntentsByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethodID,
			&i.SetupFutureUsage,
			&i.ClientSecret,
			&i.CaptureMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentIntent = `-- name: UpdatePaymentIntent :exec
UPDATE payment_intents
SET status = $2,
    payment_method_id = $3,
    setup_future_usage = $4,
    client_secret = $5,
    capture_method = $6,
    updated_at = NOW()
WHERE id = $1
`

type UpdatePaymentIntentParams struct {
	ID               string                            `json:"id"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
	CaptureMethod    PaymentIntentCaptureMethod        `json:"captureMethod"`
}

func (q *Queries) UpdatePaymentIntent(ctx context.Context, arg UpdatePaymentIntentParams) error {
	_, err := q.db.Exec(ctx, updatePaymentIntent,
		arg.ID,
		arg.Status,
		arg.PaymentMethodID,
		arg.SetupFutureUsage,
		arg.ClientSecret,
		arg.CaptureMethod,
	)
	return err
}

const upsertPaymentIntent = `-- name: UpsertPaymentIntent :exec
INSERT INTO payment_intents (
    id,customer_id, amount, currency, status, payment_method_id, setup_future_usage,client_secret
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
ON CONFLICT (id) DO UPDATE SET
                                      customer_id = EXCLUDED.customer_id,
                                      amount = EXCLUDED.amount,
                                      currency = EXCLUDED.currency,
                                      status = EXCLUDED.status,
                                      payment_method_id = EXCLUDED.payment_method_id,
                                      setup_future_usage = EXCLUDED.setup_future_usage,
                                      client_secret = EXCLUDED.client_secret,
                                      updated_at = NOW()
`

type UpsertPaymentIntentParams struct {
	ID               string                            `json:"id"`
	CustomerID       string                            `json:"customerId"`
	Amount           float64                           `json:"amount"`
	Currency         Currency                          `json:"currency"`
	Status           PaymentIntentStatus               `json:"status"`
	PaymentMethodID  *string                           `json:"paymentMethodId"`
	SetupFutureUsage NullPaymentIntentSetupFutureUsage `json:"setupFutureUsage"`
	ClientSecret     string                            `json:"clientSecret"`
}

func (q *Queries) UpsertPaymentIntent(ctx context.Context, arg UpsertPaymentIntentParams) error {
	_, err := q.db.Exec(ctx, upsertPaymentIntent,
		arg.ID,
		arg.CustomerID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethodID,
		arg.SetupFutureUsage,
		arg.ClientSecret,
	)
	return err
}
