// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: refund.sql

package sqlc

import (
	"context"
)

const createRefund = `-- name: CreateRefund :exec
INSERT INTO refunds (
    payment_intent_id,
    amount,
    status,
    reason,
    stripe_id
) VALUES (
             $1, $2, $3, $4, $5
         )
`

type CreateRefundParams struct {
	PaymentIntentID uint64       `json:"paymentIntentId"`
	Amount          float64      `json:"amount"`
	Status          RefundStatus `json:"status"`
	Reason          *string      `json:"reason"`
	StripeID        string       `json:"stripeId"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) error {
	_, err := q.db.Exec(ctx, createRefund,
		arg.PaymentIntentID,
		arg.Amount,
		arg.Status,
		arg.Reason,
		arg.StripeID,
	)
	return err
}

const deleteRefund = `-- name: DeleteRefund :exec
DELETE FROM refunds
WHERE id = $1
`

func (q *Queries) DeleteRefund(ctx context.Context, id uint64) error {
	_, err := q.db.Exec(ctx, deleteRefund, id)
	return err
}

const getRefund = `-- name: GetRefund :one
SELECT
    id,
    payment_intent_id,
    amount,
    status,
    reason,
    stripe_id,
    created_at,
    updated_at
FROM refunds
WHERE id = $1
`

func (q *Queries) GetRefund(ctx context.Context, id uint64) (*Refund, error) {
	row := q.db.QueryRow(ctx, getRefund, id)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Status,
		&i.Reason,
		&i.StripeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listByPaymentIntentID = `-- name: ListByPaymentIntentID :many
SELECT
    id,
    payment_intent_id,
    amount,
    status,
    reason,
    stripe_id,
    created_at,
    updated_at
FROM refunds
WHERE payment_intent_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListByPaymentIntentID(ctx context.Context, paymentIntentID uint64) ([]*Refund, error) {
	rows, err := q.db.Query(ctx, listByPaymentIntentID, paymentIntentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Status,
			&i.Reason,
			&i.StripeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefunds = `-- name: ListRefunds :many
SELECT
    id,
    payment_intent_id,
    amount,
    status,
    reason,
    stripe_id,
    created_at,
    updated_at
FROM refunds
WHERE payment_intent_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRefundsParams struct {
	PaymentIntentID uint64 `json:"paymentIntentId"`
	Limit           int64  `json:"limit"`
	Offset          int64  `json:"offset"`
}

func (q *Queries) ListRefunds(ctx context.Context, arg ListRefundsParams) ([]*Refund, error) {
	rows, err := q.db.Query(ctx, listRefunds, arg.PaymentIntentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Status,
			&i.Reason,
			&i.StripeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundsByStripeID = `-- name: ListRefundsByStripeID :many
SELECT
    id,
    payment_intent_id,
    amount,
    status,
    reason,
    stripe_id,
    created_at,
    updated_at
FROM refunds
WHERE stripe_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListRefundsByStripeID(ctx context.Context, stripeID string) ([]*Refund, error) {
	rows, err := q.db.Query(ctx, listRefundsByStripeID, stripeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Status,
			&i.Reason,
			&i.StripeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefund = `-- name: UpdateRefund :exec
UPDATE refunds
SET
    status = $2,
    reason = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateRefundParams struct {
	ID     uint64       `json:"id"`
	Status RefundStatus `json:"status"`
	Reason *string      `json:"reason"`
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) error {
	_, err := q.db.Exec(ctx, updateRefund, arg.ID, arg.Status, arg.Reason)
	return err
}
