// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: charge.sql

package sqlc

import (
	"context"
)

const upsertCharge = `-- name: UpsertCharge :exec
INSERT INTO charges (
    id, customer_id, payment_intent_id, amount, currency, status, paid, refunded,
    failure_code, failure_message
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         )
ON CONFLICT (id) DO UPDATE SET
                                      id = EXCLUDED.id,
                                      payment_intent_id = EXCLUDED.payment_intent_id,
                                      amount = EXCLUDED.amount,
                                      currency = EXCLUDED.currency,
                                      status = EXCLUDED.status,
                                      paid = EXCLUDED.paid,
                                      refunded = EXCLUDED.refunded,
                                      failure_code = EXCLUDED.failure_code,
                                      failure_message = EXCLUDED.failure_message,
                                      updated_at = NOW()
`

type UpsertChargeParams struct {
	ID              string       `json:"id"`
	CustomerID      *string      `json:"customerId"`
	PaymentIntentID *string      `json:"paymentIntentId"`
	Amount          float64      `json:"amount"`
	Currency        Currency     `json:"currency"`
	Status          ChargeStatus `json:"status"`
	Paid            bool         `json:"paid"`
	Refunded        bool         `json:"refunded"`
	FailureCode     *string      `json:"failureCode"`
	FailureMessage  *string      `json:"failureMessage"`
}

func (q *Queries) UpsertCharge(ctx context.Context, arg UpsertChargeParams) error {
	_, err := q.db.Exec(ctx, upsertCharge,
		arg.ID,
		arg.CustomerID,
		arg.PaymentIntentID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.Paid,
		arg.Refunded,
		arg.FailureCode,
		arg.FailureMessage,
	)
	return err
}
